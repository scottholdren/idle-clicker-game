import Decimal from 'decimal.js'
import type { 
  GameEngine as IGameEngine, 
  GameState, 
  OfflineProgress,
  Upgrade,
  IdleGenerator,
  AutomationSystem,
  Achievement,
  SaveData,
  GameSettings
} from '../types/gameTypes'
import { useGameStore } from '../stores/gameStore'
import { decimal, add, multiply, greaterThanOrEqual, ZERO, ONE } from '../utils/decimal'
import { UpgradeManager } from '../managers/UpgradeManager'
import { IdleManager } from '../managers/IdleManager'

/**
 * Core Game Engine implementation
 */
export class GameEngine implements IGameEngine {
  private updateInterval: number | null = null
  private lastUpdateTime: number = Date.now()
  private upgradeManager: UpgradeManager
  private idleManager: IdleManager

  constructor() {
    this.upgradeManager = new UpgradeManager()
    this.idleManager = new IdleManager()
    this.startGameLoop()
  }

  /**
   * Get the current game store state
   */
  private getStore() {
    return useGameStore.getState()
  }

  /**
   * Start the main game loop
   */
  private startGameLoop(): void {
    this.updateInterval = window.setInterval(() => {
      this.update()
    }, 100) // Update every 100ms for smooth gameplay
  }

  /**
   * Stop the game loop
   */
  public stopGameLoop(): void {
    if (this.updateInterval) {
      clearInterval(this.updateInterval)
      this.updateInterval = null
    }
  }

  /**
   * Main game update loop
   */
  private update(): void {
    const now = Date.now()
    const deltaTime = (now - this.lastUpdateTime) / 1000 // Convert to seconds
    this.lastUpdateTime = now

    // Initialize upgrades and generators if needed
    const state = this.getGameState()
    this.upgradeManager.initializeUpgrades(state)
    this.idleManager.initializeGenerators(state)
    
    // Track if we need to update the store
    let stateChanged = false
    
    // Update upgrade unlock conditions
    const upgradesBeforeUpdate = state.upgrades.map(u => u.unlocked)
    this.upgradeManager.updateUpgradeUnlocks(state)
    const upgradesAfterUpdate = state.upgrades.map(u => u.unlocked)
    if (JSON.stringify(upgradesBeforeUpdate) !== JSON.stringify(upgradesAfterUpdate)) {
      stateChanged = true
    }
    
    // Update generator unlock conditions
    const generatorsBeforeUpdate = state.idleGenerators.map(g => g.unlocked)
    this.idleManager.updateGeneratorUnlocks(state)
    const generatorsAfterUpdate = state.idleGenerators.map(g => g.unlocked)
    if (JSON.stringify(generatorsBeforeUpdate) !== JSON.stringify(generatorsAfterUpdate)) {
      stateChanged = true
    }

    // Update idle progress
    const idleEarnings = this.updateIdleProgress(deltaTime)
    
    // Update automation systems
    this.updateAutomation(deltaTime)
    
    // Check for achievements
    this.checkAchievements()
    
    // Auto-save if enabled
    this.handleAutoSave()
    
    // Update last active time
    this.getStore().updateLastActiveTime()
    
    // If unlock states changed, update the store
    if (stateChanged) {
      this.getStore().setGameState(state)
    }
  }

  /**
   * Perform a click action
   */
  public performClick(): Decimal {
    const state = this.getGameState()
    const clickValue = multiply(state.baseClickValue, state.clickMultiplier)
    
    // In Digital Decay, manual clicks generate Clicks (base currency)
    // Views are generated by idle generators
    this.getStore().updateCurrency(clickValue)
    this.getStore().addClicks(1)
    
    return clickValue
  }

  /**
   * Update idle progress
   */
  public updateIdleProgress(deltaTime: number): Decimal {
    const state = this.getGameState()
    
    // Calculate idle earnings using IdleManager
    const earnings = this.idleManager.updateIdleProgress(state, deltaTime)
    
    if (earnings.equals(ZERO)) {
      return ZERO
    }
    
    // In Digital Decay, idle generators produce Views (tier 2 currency)
    // Views can be converted to Clicks at a rate (e.g., 10 Views = 1 Click)
    const newState = {
      ...state,
      views: state.views.plus(earnings),
      lastActiveTime: Date.now(),
    }
    
    // Auto-convert Views to Clicks for now (simplified mechanic)
    const clicksFromViews = earnings.dividedBy(10).floor()
    if (clicksFromViews.greaterThan(ZERO)) {
      newState.currency = state.currency.plus(clicksFromViews)
      newState.totalEarned = state.totalEarned.plus(clicksFromViews)
    }
    
    this.getStore().setGameState(newState)
    
    return earnings
  }

  /**
   * Calculate offline progress
   */
  public calculateOfflineProgress(offlineTime: number): OfflineProgress {
    const state = this.getGameState()
    return this.idleManager.calculateOfflineProgress(state, offlineTime)
  }

  /**
   * Calculate total idle production per second
   */
  public calculateTotalIdleProduction(): Decimal {
    const state = this.getGameState()
    return this.idleManager.calculateTotalProduction(state)
  }

  /**
   * Update automation systems
   */
  private updateAutomation(deltaTime: number): void {
    const state = this.getGameState()
    
    for (const automation of state.automationSystems) {
      if (automation.owned > 0) {
        // Calculate clicks per this update period
        const clicksPerSecond = multiply(automation.clicksPerSecond, decimal(automation.owned))
        const clicksThisUpdate = multiply(clicksPerSecond, decimal(deltaTime))
        
        // Perform automated clicks
        const totalClicks = Math.floor(clicksThisUpdate.toNumber())
        for (let i = 0; i < totalClicks; i++) {
          this.performClick()
        }
      }
    }
  }

  /**
   * Calculate automation earnings for offline progress
   */
  private calculateAutomationEarnings(seconds: number): Decimal {
    const state = this.getGameState()
    let totalEarnings = ZERO
    
    for (const automation of state.automationSystems) {
      if (automation.owned > 0) {
        const clicksPerSecond = multiply(automation.clicksPerSecond, decimal(automation.owned))
        const totalClicks = multiply(clicksPerSecond, decimal(seconds))
        const clickValue = multiply(state.baseClickValue, state.clickMultiplier)
        const earnings = multiply(totalClicks, clickValue)
        
        totalEarnings = add(totalEarnings, earnings)
      }
    }
    
    return totalEarnings
  }

  /**
   * Calculate automation clicks for offline progress
   */
  private calculateAutomationClicks(seconds: number): number {
    const state = this.getGameState()
    let totalClicks = 0
    
    for (const automation of state.automationSystems) {
      if (automation.owned > 0) {
        const clicksPerSecond = multiply(automation.clicksPerSecond, decimal(automation.owned))
        const clicks = multiply(clicksPerSecond, decimal(seconds))
        totalClicks += Math.floor(clicks.toNumber())
      }
    }
    
    return totalClicks
  }

  /**
   * Purchase an upgrade
   */
  public purchaseUpgrade(upgradeId: string): boolean {
    const state = this.getGameState()
    const success = this.upgradeManager.purchaseUpgrade(upgradeId, state)
    
    if (success) {
      // Update the store with the modified state
      this.getStore().setGameState(state)
    }
    
    return success
  }

  /**
   * Check if player can afford an upgrade
   */
  public canAffordUpgrade(upgrade: Upgrade): boolean {
    const state = this.getGameState()
    return this.upgradeManager.canAffordUpgrade(upgrade, state)
  }

  /**
   * Get the cost of an upgrade
   */
  public getUpgradeCost(upgrade: Upgrade): Decimal {
    return this.upgradeManager.getUpgradeCost(upgrade)
  }

  /**
   * Get all available upgrades
   */
  public getAvailableUpgrades(): Upgrade[] {
    const state = this.getGameState()
    return this.upgradeManager.getAvailableUpgrades(state)
  }

  /**
   * Get all visible upgrades
   */
  public getVisibleUpgrades(): Upgrade[] {
    const state = this.getGameState()
    return this.upgradeManager.getVisibleUpgrades(state)
  }

  /**
   * Purchase idle generators
   */
  public purchaseGenerator(generatorId: string, amount: number = 1): boolean {
    const state = this.getGameState()
    const success = this.idleManager.purchaseGenerator(generatorId, state, amount)
    
    if (success) {
      // Update the store with the modified state
      this.getStore().setGameState(state)
    }
    
    return success
  }

  /**
   * Check if player can afford generators
   */
  public canAffordGenerator(generator: IdleGenerator, amount: number = 1): boolean {
    const state = this.getGameState()
    return this.idleManager.canAffordGenerator(generator, state, amount)
  }

  /**
   * Get the cost of purchasing generators
   */
  public getGeneratorCost(generator: IdleGenerator, amount: number = 1): Decimal {
    return this.idleManager.getGeneratorCost(generator, amount)
  }

  /**
   * Check if player can prestige
   */
  public canPrestige(): boolean {
    // Implement prestige requirements
    // For now, require at least 1000 total currency earned
    const state = this.getGameState()
    return greaterThanOrEqual(state.totalEarned, decimal(1000))
  }

  /**
   * Perform prestige reset
   */
  public performPrestige(): void {
    if (!this.canPrestige()) {
      return
    }
    
    const prestigeGain = this.calculatePrestigeGain()
    const state = this.getGameState()
    
    // Reset base progress
    const newState: GameState = {
      ...state,
      currency: ZERO,
      totalClicks: 0,
      totalEarned: ZERO,
      baseClickValue: ONE,
      clickMultiplier: ONE,
      idleGenerators: state.idleGenerators.map(g => ({ ...g, owned: 0 })),
      idleMultiplier: ONE,
      upgrades: state.upgrades.map(u => ({ ...u, currentPurchases: 0 })),
      purchasedUpgrades: new Set<string>(),
      automationSystems: state.automationSystems.map(a => ({ ...a, owned: 0 })),
      
      // Keep prestige progress
      prestigePoints: add(state.prestigePoints, prestigeGain),
      totalPrestiges: state.totalPrestiges + 1,
      
      // Keep meta prestige and achievements
      metaPrestigePoints: state.metaPrestigePoints,
      metaPrestigeUpgrades: state.metaPrestigeUpgrades,
      purchasedMetaPrestigeUpgrades: state.purchasedMetaPrestigeUpgrades,
      totalMetaPrestiges: state.totalMetaPrestiges,
      achievements: state.achievements,
      unlockedAchievements: state.unlockedAchievements,
      
      // Reset times
      gameStartTime: Date.now(),
      lastSaveTime: Date.now(),
      lastActiveTime: Date.now(),
    }
    
    this.getStore().setGameState(newState)
  }

  /**
   * Calculate prestige gain
   */
  public calculatePrestigeGain(): Decimal {
    const state = this.getGameState()
    // Simple formula: sqrt(totalEarned / 1000)
    const gain = state.totalEarned.dividedBy(1000).sqrt().floor()
    return gain.greaterThan(ZERO) ? gain : ONE
  }

  /**
   * Purchase prestige upgrade
   */
  public purchasePrestigeUpgrade(upgradeId: string): boolean {
    // Implementation will be added when prestige upgrades are defined
    return false
  }

  /**
   * Check if player can meta prestige
   */
  public canMetaPrestige(): boolean {
    const state = this.getGameState()
    return state.totalPrestiges >= 10 && greaterThanOrEqual(state.prestigePoints, decimal(1000))
  }

  /**
   * Perform meta prestige reset
   */
  public performMetaPrestige(): void {
    if (!this.canMetaPrestige()) {
      return
    }
    
    const metaPrestigeGain = this.calculateMetaPrestigeGain()
    const state = this.getGameState()
    
    // Reset everything except meta prestige and achievements
    const newState: GameState = {
      ...state,
      currency: ZERO,
      totalClicks: 0,
      totalEarned: ZERO,
      baseClickValue: ONE,
      clickMultiplier: ONE,
      idleGenerators: state.idleGenerators.map(g => ({ ...g, owned: 0 })),
      idleMultiplier: ONE,
      offlineProgressRate: 0,
      maxOfflineHours: 1,
      upgrades: state.upgrades.map(u => ({ ...u, currentPurchases: 0 })),
      purchasedUpgrades: new Set<string>(),
      prestigePoints: ZERO,
      prestigeUpgrades: state.prestigeUpgrades.map(u => ({ ...u, currentPurchases: 0 })),
      purchasedPrestigeUpgrades: new Set<string>(),
      totalPrestiges: 0,
      automationSystems: state.automationSystems.map(a => ({ ...a, owned: 0 })),
      
      // Keep meta prestige progress
      metaPrestigePoints: add(state.metaPrestigePoints, metaPrestigeGain),
      totalMetaPrestiges: state.totalMetaPrestiges + 1,
      
      // Keep achievements
      achievements: state.achievements,
      unlockedAchievements: state.unlockedAchievements,
      
      // Reset times
      gameStartTime: Date.now(),
      lastSaveTime: Date.now(),
      lastActiveTime: Date.now(),
    }
    
    this.getStore().setGameState(newState)
  }

  /**
   * Calculate meta prestige gain
   */
  public calculateMetaPrestigeGain(): Decimal {
    const state = this.getGameState()
    // Formula: sqrt(prestigePoints / 100)
    const gain = state.prestigePoints.dividedBy(100).sqrt().floor()
    return gain.greaterThan(ZERO) ? gain : ONE
  }

  /**
   * Purchase meta prestige upgrade
   */
  public purchaseMetaPrestigeUpgrade(upgradeId: string): boolean {
    // Implementation will be added when meta prestige upgrades are defined
    return false
  }

  /**
   * Purchase automation systems
   */
  public purchaseAutomation(automationId: string, amount: number = 1): boolean {
    const state = this.getGameState()
    const automation = state.automationSystems.find(a => a.id === automationId)
    
    if (!automation || !this.canAffordAutomation(automation, amount)) {
      return false
    }
    
    const cost = this.getAutomationCost(automation, amount)
    
    // Deduct cost
    this.getStore().updateCurrency(cost.negated())
    
    // Add automation
    automation.owned += amount
    
    return true
  }

  /**
   * Check if player can afford automation
   */
  public canAffordAutomation(automation: AutomationSystem, amount: number = 1): boolean {
    const state = this.getGameState()
    
    if (!automation.unlocked) {
      return false
    }
    
    const cost = this.getAutomationCost(automation, amount)
    return greaterThanOrEqual(state.currency, cost)
  }

  /**
   * Get automation cost
   */
  public getAutomationCost(automation: AutomationSystem, amount: number = 1): Decimal {
    let totalCost = ZERO
    
    for (let i = 0; i < amount; i++) {
      const currentOwned = automation.owned + i
      const multiplier = automation.costMultiplier.pow(currentOwned)
      const cost = multiply(automation.baseCost, multiplier)
      totalCost = add(totalCost, cost)
    }
    
    return totalCost
  }

  /**
   * Check achievements
   */
  public checkAchievements(): Achievement[] {
    const state = this.getGameState()
    const newlyUnlocked: Achievement[] = []
    
    for (const achievement of state.achievements) {
      if (!achievement.unlocked && achievement.unlockCondition(state)) {
        achievement.unlocked = true
        state.unlockedAchievements.add(achievement.id)
        
        // Apply reward if exists
        if (achievement.reward) {
          achievement.reward.apply(state)
        }
        
        newlyUnlocked.push(achievement)
      }
    }
    
    return newlyUnlocked
  }

  /**
   * Unlock specific achievement
   */
  public unlockAchievement(achievementId: string): boolean {
    const state = this.getGameState()
    const achievement = state.achievements.find(a => a.id === achievementId)
    
    if (!achievement || achievement.unlocked) {
      return false
    }
    
    achievement.unlocked = true
    state.unlockedAchievements.add(achievementId)
    
    if (achievement.reward) {
      achievement.reward.apply(state)
    }
    
    return true
  }

  /**
   * Save game
   */
  public saveGame(): void {
    this.getStore().saveGame()
  }

  /**
   * Load game
   */
  public loadGame(saveData: SaveData): boolean {
    try {
      this.getStore().loadGame(saveData)
      return true
    } catch (error) {
      console.error('Failed to load game:', error)
      return false
    }
  }

  /**
   * Export save
   */
  public exportSave(): string {
    return this.getStore().exportSave()
  }

  /**
   * Import save
   */
  public importSave(saveString: string): boolean {
    return this.getStore().importSave(saveString)
  }

  /**
   * Get current game state
   */
  public getGameState(): GameState {
    return this.getStore().getGameState()
  }

  /**
   * Update settings
   */
  public updateSettings(settings: Partial<GameSettings>): void {
    this.getStore().updateSettings(settings)
  }

  /**
   * Reset game
   */
  public resetGame(): void {
    this.getStore().resetGame()
  }

  /**
   * Handle auto-save
   */
  private handleAutoSave(): void {
    const state = this.getGameState()
    
    if (!state.settings.autoSave) {
      return
    }
    
    const now = Date.now()
    const timeSinceLastSave = (now - state.lastSaveTime) / 1000
    
    if (timeSinceLastSave >= state.settings.autoSaveInterval) {
      this.saveGame()
    }
  }
}

/**
 * Global game engine instance
 */
export const gameEngine = new GameEngine()

/**
 * Debug utility to clear localStorage (call from browser console)
 */
if (typeof window !== 'undefined') {
  (window as any).clearGameData = () => {
    console.log('Clearing game data and reloading...')
    localStorage.removeItem('idle-clicker-game-storage')
    window.location.reload()
  }
  
  (window as any).debugGameState = () => {
    const state = gameEngine.getGameState()
    console.log('Current Game State:')
    console.log('Currency:', state.currency.toString())
    console.log('Total Earned:', state.totalEarned.toString())
    console.log('Total Clicks:', state.totalClicks)
    console.log('Generators:', state.idleGenerators.map(g => ({
      id: g.id,
      name: g.name,
      unlocked: g.unlocked,
      owned: g.owned
    })))
    return state
  }
  
  console.log('Debug commands available:')
  console.log('- clearGameData() - Clear all save data and reload')
  console.log('- debugGameState() - Show current game state')
}