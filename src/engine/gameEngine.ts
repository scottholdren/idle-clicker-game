import Decimal from 'decimal.js'
import type { 
  GameEngine as IGameEngine, 
  GameState, 
  OfflineProgress,
  Upgrade,
  IdleGenerator,
  AutomationSystem,
  Achievement,
  SaveData,
  GameSettings
} from '../types/gameTypes'
import { useGameStore, getBaseClickBoost } from '../stores/gameStore'
import { decimal, add, multiply, greaterThanOrEqual, calculateStrategyPointsMultiplier, calculateViewToClickEfficiency, ZERO, ONE } from '../utils/decimal'
import { UpgradeManager } from '../managers/UpgradeManager'
import { IdleManager } from '../managers/IdleManager'

/**
 * Get prestige threshold - fixed at production value
 */
const getPrestigeThreshold = () => {
  return 50000 // Production value
}

/**
 * Core Game Engine implementation
 */
export class GameEngine implements IGameEngine {
  private updateInterval: number | null = null
  private lastUpdateTime: number = Date.now()
  private upgradeManager: UpgradeManager
  private idleManager: IdleManager

  constructor() {
    this.upgradeManager = new UpgradeManager()
    this.idleManager = new IdleManager()
    this.startGameLoop()
  }

  /**
   * Get the current game store state
   */
  private getStore() {
    return useGameStore.getState()
  }

  /**
   * Start the main game loop
   */
  private startGameLoop(): void {
    this.updateInterval = window.setInterval(() => {
      this.update()
    }, 100) // Update every 100ms for smooth gameplay
  }

  /**
   * Stop the game loop
   */
  public stopGameLoop(): void {
    if (this.updateInterval) {
      clearInterval(this.updateInterval)
      this.updateInterval = null
    }
  }

  /**
   * Main game update loop
   */
  private update(): void {
    const now = Date.now()
    const deltaTime = (now - this.lastUpdateTime) / 1000 // Convert to seconds
    this.lastUpdateTime = now

    // Initialize upgrades and generators if needed
    const state = this.getGameState()
    this.upgradeManager.initializeUpgrades(state)
    this.idleManager.initializeGenerators(state)
    
    // Track if we need to update the store
    let stateChanged = false
    
    // Update upgrade unlock conditions
    const upgradesBeforeUpdate = state.upgrades.map(u => u.unlocked)
    this.upgradeManager.updateUpgradeUnlocks(state)
    const upgradesAfterUpdate = state.upgrades.map(u => u.unlocked)
    if (JSON.stringify(upgradesBeforeUpdate) !== JSON.stringify(upgradesAfterUpdate)) {
      stateChanged = true
    }
    
    // Update generator unlock conditions
    const generatorsBeforeUpdate = state.idleGenerators.map(g => g.unlocked)
    this.idleManager.updateGeneratorUnlocks(state)
    const generatorsAfterUpdate = state.idleGenerators.map(g => g.unlocked)
    if (JSON.stringify(generatorsBeforeUpdate) !== JSON.stringify(generatorsAfterUpdate)) {
      stateChanged = true
    }

    // Update temporary effects
    this.updateTemporaryEffects()
    
    // Update idle progress
    this.updateIdleProgress(deltaTime)
    
    // Update automation systems
    this.updateAutomation(deltaTime)
    
    // Check for achievements
    this.checkAchievements()
    
    // Auto-save if enabled
    this.handleAutoSave()
    
    // Update last active time
    this.getStore().updateLastActiveTime()
    
    // If unlock states changed, update the store
    if (stateChanged) {
      this.getStore().setGameState(state)
    }
  }

  /**
   * Perform a click action
   */
  public performClick(): Decimal {
    const state = this.getGameState()
    
    // Calculate base click value with multipliers
    let clickValue = multiply(state.baseClickValue, state.clickMultiplier)
    
    // Add base click boost for testing
    const baseBoost = getBaseClickBoost()
    if (baseBoost > 0) {
      clickValue = clickValue.plus(baseBoost)
    }
    
    // Apply strategy points bonus
    const strategyBonus = calculateStrategyPointsMultiplier(state.prestigePoints)
    clickValue = multiply(clickValue, strategyBonus)
    
    // In Digital Decay, manual clicks generate Clicks (base currency)
    // Views are generated by idle generators
    this.getStore().updateCurrency(clickValue)
    this.getStore().addManualClick() // Track this as a manual click for rate calculation
    
    return clickValue
  }

  /**
   * Update idle progress
   */
  public updateIdleProgress(deltaTime: number): Decimal {
    const state = this.getGameState()
    
    // Calculate idle earnings using IdleManager
    let earnings = this.idleManager.updateIdleProgress(state, deltaTime)
    
    if (earnings.equals(ZERO)) {
      return ZERO
    }
    
    // Apply strategy points bonus to idle generation
    const strategyBonus = calculateStrategyPointsMultiplier(state.prestigePoints)
    earnings = multiply(earnings, strategyBonus)
    
    // In Digital Decay, idle generators produce Views (tier 2 currency)
    const newViews = state.views.plus(earnings) // Don't floor here, let Views accumulate as decimals internally
    
    // Calculate view-to-click efficiency based on total earned clicks and prestige multiplier
    const efficiency = calculateViewToClickEfficiency(state.totalEarned, strategyBonus)
    
    // Calculate how many Clicks we should have based on total Views with efficiency
    const totalClicksFromViews = newViews.times(efficiency).floor()
    
    // Calculate how many Clicks we already have from previous Views
    const currentClicksFromViews = state.views.times(efficiency).floor()
    
    // Only add the new Clicks from the new Views
    const newClicksToAdd = totalClicksFromViews.minus(currentClicksFromViews)
    
    const newState = {
      ...state,
      views: newViews, // Keep accumulating Views (with decimals internally)
      currency: state.currency.plus(newClicksToAdd), // Add only new Clicks
      totalEarned: state.totalEarned.plus(newClicksToAdd),
      lastActiveTime: Date.now(),
    }
    
    this.getStore().setGameState(newState)
    
    return earnings
  }

  /**
   * Calculate offline progress
   */
  public calculateOfflineProgress(offlineTime: number): OfflineProgress {
    const state = this.getGameState()
    return this.idleManager.calculateOfflineProgress(state, offlineTime)
  }

  /**
   * Calculate total idle production per second
   */
  public calculateTotalIdleProduction(): Decimal {
    const state = this.getGameState()
    return this.idleManager.calculateTotalProduction(state)
  }

  /**
   * Update temporary effects and remove expired ones
   */
  private updateTemporaryEffects(): void {
    const state = this.getGameState()
    
    // Safety check: ensure state exists and temporaryEffects array exists
    if (!state) {
      console.warn('Game state is undefined in updateTemporaryEffects')
      return
    }
    
    if (!state.temporaryEffects) {
      state.temporaryEffects = []
      // Update the store with the initialized array
      this.getStore().setGameState(state)
      return
    }
    
    if (!Array.isArray(state.temporaryEffects)) {
      console.warn('temporaryEffects is not an array, reinitializing')
      state.temporaryEffects = []
      // Update the store with the reinitialized array
      this.getStore().setGameState(state)
      return
    }
    
    const now = Date.now()
    const expiredEffects: number[] = []
    
    // Check for expired effects
    for (let i = 0; i < state.temporaryEffects.length; i++) {
      const effect = state.temporaryEffects[i]
      
      // Safety check for effect object
      if (!effect || typeof effect.startTime !== 'number' || typeof effect.duration !== 'number') {
        console.warn(`Invalid temporary effect at index ${i}:`, effect)
        expiredEffects.push(i)
        continue
      }
      
      const elapsed = now - effect.startTime
      
      if (elapsed >= effect.duration) {
        // Effect has expired, remove it
        try {
          if (typeof effect.remove === 'function') {
            effect.remove(state)
          }
        } catch (error) {
          console.warn(`Error removing temporary effect ${effect.id}:`, error)
        }
        expiredEffects.push(i)
      }
    }
    
    // Remove expired effects (in reverse order to maintain indices)
    for (let i = expiredEffects.length - 1; i >= 0; i--) {
      state.temporaryEffects.splice(expiredEffects[i], 1)
    }
    
    // Update the store if any effects were removed
    if (expiredEffects.length > 0) {
      this.getStore().setGameState(state)
    }
  }

  /**
   * Update automation systems
   */
  private updateAutomation(deltaTime: number): void {
    const state = this.getGameState()
    
    for (const automation of state.automationSystems) {
      if (automation.owned > 0) {
        // Calculate clicks per this update period
        const clicksPerSecond = multiply(automation.clicksPerSecond, decimal(automation.owned))
        const clicksThisUpdate = multiply(clicksPerSecond, decimal(deltaTime))
        
        // Apply strategy points bonus to automation
        const strategyBonus = calculateStrategyPointsMultiplier(state.prestigePoints)
        const bonusClicksThisUpdate = multiply(clicksThisUpdate, strategyBonus)
        
        // Perform automated clicks
        const totalClicks = Math.floor(bonusClicksThisUpdate.toNumber())
        for (let i = 0; i < totalClicks; i++) {
          // Use base click value without strategy bonus since we already applied it above
          const baseClickValue = multiply(state.baseClickValue, state.clickMultiplier)
          this.getStore().updateCurrency(baseClickValue)
        }
      }
    }
  }

  /**
   * Calculate automation earnings for offline progress
   */
  private calculateAutomationEarnings(seconds: number): Decimal {
    const state = this.getGameState()
    let totalEarnings = ZERO
    
    for (const automation of state.automationSystems) {
      if (automation.owned > 0) {
        const clicksPerSecond = multiply(automation.clicksPerSecond, decimal(automation.owned))
        const totalClicks = multiply(clicksPerSecond, decimal(seconds))
        const clickValue = multiply(state.baseClickValue, state.clickMultiplier)
        
        // Apply strategy points bonus
        const strategyBonus = calculateStrategyPointsMultiplier(state.prestigePoints)
        const bonusClickValue = multiply(clickValue, strategyBonus)
        
        const earnings = multiply(totalClicks, bonusClickValue)
        totalEarnings = add(totalEarnings, earnings)
      }
    }
    
    return totalEarnings
  }

  /**
   * Calculate automation clicks for offline progress
   */
  private calculateAutomationClicks(seconds: number): number {
    const state = this.getGameState()
    let totalClicks = 0
    
    for (const automation of state.automationSystems) {
      if (automation.owned > 0) {
        const clicksPerSecond = multiply(automation.clicksPerSecond, decimal(automation.owned))
        const clicks = multiply(clicksPerSecond, decimal(seconds))
        totalClicks += Math.floor(clicks.toNumber())
      }
    }
    
    return totalClicks
  }

  /**
   * Purchase an upgrade
   */
  public purchaseUpgrade(upgradeId: string): boolean {
    const state = this.getGameState()
    const success = this.upgradeManager.purchaseUpgrade(upgradeId, state)
    
    if (success) {
      // Update the store with the modified state
      this.getStore().setGameState(state)
    }
    
    return success
  }

  /**
   * Purchase maximum affordable upgrades
   */
  public purchaseMaxUpgrades(upgradeId: string): number {
    const state = this.getGameState()
    const purchased = this.upgradeManager.purchaseMaxUpgrades(upgradeId, state)
    
    if (purchased > 0) {
      // Update the store with the modified state
      this.getStore().setGameState(state)
    }
    
    return purchased
  }

  /**
   * Get maximum affordable upgrades
   */
  public getMaxAffordableUpgrades(upgrade: any): number {
    const state = this.getGameState()
    return this.upgradeManager.getMaxAffordableUpgrades(upgrade, state)
  }

  /**
   * Check if player can afford an upgrade
   */
  public canAffordUpgrade(upgrade: Upgrade): boolean {
    const state = this.getGameState()
    return this.upgradeManager.canAffordUpgrade(upgrade, state)
  }

  /**
   * Get the cost of an upgrade
   */
  public getUpgradeCost(upgrade: Upgrade): Decimal {
    return this.upgradeManager.getUpgradeCost(upgrade)
  }

  /**
   * Get all available upgrades
   */
  public getAvailableUpgrades(): Upgrade[] {
    const state = this.getGameState()
    return this.upgradeManager.getAvailableUpgrades(state)
  }

  /**
   * Get all visible upgrades
   */
  public getVisibleUpgrades(): Upgrade[] {
    const state = this.getGameState()
    return this.upgradeManager.getVisibleUpgrades(state)
  }

  /**
   * Purchase idle generators
   */
  public purchaseGenerator(generatorId: string, amount: number = 1): boolean {
    const state = this.getGameState()
    const success = this.idleManager.purchaseGenerator(generatorId, state, amount)
    
    if (success) {
      // Update the store with the modified state
      this.getStore().setGameState(state)
    }
    
    return success
  }

  /**
   * Purchase maximum affordable generators
   */
  public purchaseMaxGenerators(generatorId: string): number {
    const state = this.getGameState()
    const purchased = this.idleManager.purchaseMaxGenerators(generatorId, state)
    
    if (purchased > 0) {
      // Update the store with the modified state
      this.getStore().setGameState(state)
    }
    
    return purchased
  }

  /**
   * Get maximum affordable generators
   */
  public getMaxAffordableGenerators(generator: any): number {
    const state = this.getGameState()
    return this.idleManager.getMaxAffordableGenerators(generator, state)
  }

  /**
   * Check if player can afford generators
   */
  public canAffordGenerator(generator: IdleGenerator, amount: number = 1): boolean {
    const state = this.getGameState()
    return this.idleManager.canAffordGenerator(generator, state, amount)
  }

  /**
   * Get the cost of purchasing generators
   */
  public getGeneratorCost(generator: IdleGenerator, amount: number = 1): Decimal {
    return this.idleManager.getGeneratorCost(generator, amount)
  }

  /**
   * Check if player can prestige
   */
  public canPrestige(): boolean {
    // Implement prestige requirements with testing/production values
    const state = this.getGameState()
    return greaterThanOrEqual(state.totalEarned, decimal(getPrestigeThreshold()))
  }

  /**
   * Perform prestige reset
   */
  public performPrestige(): void {
    if (!this.canPrestige()) {
      return
    }
    
    const prestigeGain = this.calculatePrestigeGain()
    const state = this.getGameState()
    
    // Reset base progress
    const newState: GameState = {
      ...state,
      currency: ZERO,
      totalClicks: 0,
      totalEarned: ZERO,
      baseClickValue: ONE,
      clickMultiplier: ONE,
      idleGenerators: state.idleGenerators.map(g => ({ ...g, owned: 0 })),
      idleMultiplier: ONE,
      upgrades: state.upgrades.map(u => ({ ...u, currentPurchases: 0 })),
      purchasedUpgrades: new Set<string>(),
      automationSystems: state.automationSystems.map(a => ({ ...a, owned: 0 })),
      
      // Keep prestige progress
      prestigePoints: add(state.prestigePoints, prestigeGain),
      totalPrestiges: state.totalPrestiges + 1,
      
      // Keep meta prestige and achievements
      metaPrestigePoints: state.metaPrestigePoints,
      metaPrestigeUpgrades: state.metaPrestigeUpgrades,
      purchasedMetaPrestigeUpgrades: state.purchasedMetaPrestigeUpgrades,
      totalMetaPrestiges: state.totalMetaPrestiges,
      achievements: state.achievements,
      unlockedAchievements: state.unlockedAchievements,
      
      // Reset times
      gameStartTime: Date.now(),
      lastSaveTime: Date.now(),
      lastActiveTime: Date.now(),
    }
    
    this.getStore().setGameState(newState)
  }

  /**
   * Calculate prestige gain
   */
  public calculatePrestigeGain(): Decimal {
    const state = this.getGameState()
    // Formula: sqrt(totalEarned / threshold) where threshold varies by mode
    const threshold = getPrestigeThreshold()
    const gain = state.totalEarned.dividedBy(threshold).sqrt().floor()
    return gain.greaterThan(ZERO) ? gain : ONE
  }

  /**
   * Purchase prestige upgrade
   */
  public purchasePrestigeUpgrade(upgradeId: string): boolean {
    // Implementation will be added when prestige upgrades are defined
    console.log(`Prestige upgrade ${upgradeId} not yet implemented`)
    return false
  }

  /**
   * Check if player can meta prestige
   */
  public canMetaPrestige(): boolean {
    const state = this.getGameState()
    return state.totalPrestiges >= 10 && greaterThanOrEqual(state.prestigePoints, decimal(1000))
  }

  /**
   * Perform meta prestige reset
   */
  public performMetaPrestige(): void {
    if (!this.canMetaPrestige()) {
      return
    }
    
    const metaPrestigeGain = this.calculateMetaPrestigeGain()
    const state = this.getGameState()
    
    // Reset everything except meta prestige and achievements
    const newState: GameState = {
      ...state,
      currency: ZERO,
      totalClicks: 0,
      totalEarned: ZERO,
      baseClickValue: ONE,
      clickMultiplier: ONE,
      idleGenerators: state.idleGenerators.map(g => ({ ...g, owned: 0 })),
      idleMultiplier: ONE,
      offlineProgressRate: 0,
      maxOfflineHours: 1,
      upgrades: state.upgrades.map(u => ({ ...u, currentPurchases: 0 })),
      purchasedUpgrades: new Set<string>(),
      prestigePoints: ZERO,
      prestigeUpgrades: state.prestigeUpgrades.map(u => ({ ...u, currentPurchases: 0 })),
      purchasedPrestigeUpgrades: new Set<string>(),
      totalPrestiges: 0,
      automationSystems: state.automationSystems.map(a => ({ ...a, owned: 0 })),
      
      // Keep meta prestige progress
      metaPrestigePoints: add(state.metaPrestigePoints, metaPrestigeGain),
      totalMetaPrestiges: state.totalMetaPrestiges + 1,
      
      // Keep achievements
      achievements: state.achievements,
      unlockedAchievements: state.unlockedAchievements,
      
      // Reset times
      gameStartTime: Date.now(),
      lastSaveTime: Date.now(),
      lastActiveTime: Date.now(),
    }
    
    this.getStore().setGameState(newState)
  }

  /**
   * Calculate meta prestige gain
   */
  public calculateMetaPrestigeGain(): Decimal {
    const state = this.getGameState()
    // Formula: sqrt(prestigePoints / 100)
    const gain = state.prestigePoints.dividedBy(100).sqrt().floor()
    return gain.greaterThan(ZERO) ? gain : ONE
  }

  /**
   * Purchase meta prestige upgrade
   */
  public purchaseMetaPrestigeUpgrade(upgradeId: string): boolean {
    // Implementation will be added when meta prestige upgrades are defined
    console.log(`Meta prestige upgrade ${upgradeId} not yet implemented`)
    return false
  }

  /**
   * Purchase automation systems
   */
  public purchaseAutomation(automationId: string, amount: number = 1): boolean {
    const state = this.getGameState()
    const automation = state.automationSystems.find(a => a.id === automationId)
    
    if (!automation || !this.canAffordAutomation(automation, amount)) {
      return false
    }
    
    const cost = this.getAutomationCost(automation, amount)
    
    // Deduct cost
    this.getStore().updateCurrency(cost.negated())
    
    // Add automation
    automation.owned += amount
    
    return true
  }

  /**
   * Check if player can afford automation
   */
  public canAffordAutomation(automation: AutomationSystem, amount: number = 1): boolean {
    const state = this.getGameState()
    
    if (!automation.unlocked) {
      return false
    }
    
    const cost = this.getAutomationCost(automation, amount)
    return greaterThanOrEqual(state.currency, cost)
  }

  /**
   * Get automation cost
   */
  public getAutomationCost(automation: AutomationSystem, amount: number = 1): Decimal {
    let totalCost = ZERO
    
    for (let i = 0; i < amount; i++) {
      const currentOwned = automation.owned + i
      const multiplier = automation.costMultiplier.pow(currentOwned)
      const cost = multiply(automation.baseCost, multiplier)
      totalCost = add(totalCost, cost)
    }
    
    return totalCost
  }

  /**
   * Check achievements
   */
  public checkAchievements(): Achievement[] {
    const state = this.getGameState()
    const newlyUnlocked: Achievement[] = []
    
    for (const achievement of state.achievements) {
      if (!achievement.unlocked && achievement.unlockCondition(state)) {
        achievement.unlocked = true
        state.unlockedAchievements.add(achievement.id)
        
        // Apply reward if exists
        if (achievement.reward) {
          achievement.reward.apply(state)
        }
        
        newlyUnlocked.push(achievement)
      }
    }
    
    return newlyUnlocked
  }

  /**
   * Unlock specific achievement
   */
  public unlockAchievement(achievementId: string): boolean {
    const state = this.getGameState()
    const achievement = state.achievements.find(a => a.id === achievementId)
    
    if (!achievement || achievement.unlocked) {
      return false
    }
    
    achievement.unlocked = true
    state.unlockedAchievements.add(achievementId)
    
    if (achievement.reward) {
      achievement.reward.apply(state)
    }
    
    return true
  }

  /**
   * Save game
   */
  public saveGame(): void {
    this.getStore().saveGame()
  }

  /**
   * Load game
   */
  public loadGame(saveData: SaveData): boolean {
    try {
      this.getStore().loadGame(saveData)
      return true
    } catch (error) {
      console.error('Failed to load game:', error)
      return false
    }
  }

  /**
   * Export save
   */
  public exportSave(): string {
    return this.getStore().exportSave()
  }

  /**
   * Import save
   */
  public importSave(saveString: string): boolean {
    return this.getStore().importSave(saveString)
  }

  /**
   * Get the upgrade manager instance
   */
  public getUpgradeManager(): UpgradeManager {
    return this.upgradeManager
  }

  /**
   * Calculate cumulative effect for an upgrade
   */
  public calculateUpgradeCumulativeEffect(upgrade: Upgrade): { type: string; value: import('decimal.js').default } {
    return this.upgradeManager.calculateCumulativeEffect(upgrade)
  }
  public getGameState(): GameState {
    return this.getStore().getGameState()
  }

  /**
   * Update settings
   */
  public updateSettings(settings: Partial<GameSettings>): void {
    this.getStore().updateSettings(settings)
  }



  /**
   * Reset game
   */
  public resetGame(): void {
    this.getStore().resetGame()
  }

  /**
   * Handle auto-save
   */
  private handleAutoSave(): void {
    const state = this.getGameState()
    
    if (!state.settings.autoSave) {
      return
    }
    
    const now = Date.now()
    const timeSinceLastSave = (now - state.lastSaveTime) / 1000
    
    if (timeSinceLastSave >= state.settings.autoSaveInterval) {
      this.saveGame()
    }
  }
}

/**
 * Global game engine instance
 */
export const gameEngine = new GameEngine()

/**
 * Debug utility to clear localStorage (call from browser console)
 */
if (typeof window !== 'undefined') {
  (window as any).clearGameData = () => {
    console.log('Clearing game data and reloading...')
    localStorage.removeItem('idle-clicker-game-storage')
    window.location.reload()
  }
  
  (window as any).debugGameState = () => {
    const state = gameEngine.getGameState()
    console.log('Current Game State:')
    console.log('Currency:', state.currency.toString())
    console.log('Total Earned:', state.totalEarned.toString())
    console.log('Total Clicks:', state.totalClicks)
    console.log('Generators:', state.idleGenerators.map(g => ({
      id: g.id,
      name: g.name,
      unlocked: g.unlocked,
      owned: g.owned
    })))
    return state
  }
  
  console.log('Debug commands available:')
  console.log('- clearGameData() - Clear all save data and reload')
  console.log('- debugGameState() - Show current game state')
}